from gen_signal import generate_signal, spectrogram
import numpy as np
from math import ceil

def sampling (signal, n1, n2, zero):
    """
    Return the co-prime sampled signals.
    The format of return values is a 2-d matrix:
        (index in original signal, signal value)
    Input:  signal values (1-d vector)
            n1, n2: the relative sampling points generated by coprime pairs
            zero: relative zero point along with moving window.
    """
    x1 = np.array([[zero+n1[i], signal[zero+n1[i]]] for i in range(len(n1)) if zero+n1[i]<len(signal)])
    x2 = np.array([[zero+n2[i], signal[zero+n2[i]]] for i in range(len(n2)) if zero+n2[i]>=0 and zero+n2[i]<len(signal)])
    return x1, x2

def autocorrelation(r_xx, x1, x2, zero):
    """
    Calculate the autocorrelation operating upon the r_xx.
    Return the modified array of autocorrelation.
    Input:  r_xx: previous autocorrelation.
            x1, x2: co-prime sampled signal.
            zero: relative zero point along with moving window.
    """
    for i in range(len(x1)):
        for j in range(len(x2)):
            index = abs(x1[i][0]-x2[j][0])
            if zero+index < len(r_xx):
                index += zero
                if r_xx[index][1] == 0:
                    r_xx[index][0] = x1[i][1]*(x2[j][1].conj())
                    r_xx[index][1] += 1
                else:
                    r_xx[index][0] = (r_xx[index][1]*r_xx[index][0] + x1[i][1]*(x2[j][1].conj())) / (r_xx[index][1]+1)
                    r_xx[index][1] += 1
    return r_xx

def main (signal, window_size=256):
    # the times of moving for window
    steps = int(ceil(len(signal)/float(window_size)))
    # the co-prime pair
    a = 19
    b = 17
    # calculate the range to generate hole-free co-prime combinations 
    n1 = np.arange(0,a)*b
    n2 = np.arange(-b+1,b)*a
    print n1
    print n2
    # r_xx with the same length of signal to store and average estimations
    # 1st column is the value of autocorrelation
    # 2nd column is the # of sample points contribute to this autocorrelation
    r_xx = np.zeros((len(signal),2))

    for i in range(steps):
        # the relative zero point for the current window
        zero = i*window_size
        # slicing the signal and conduct co-prime sampling 
        x1, x2 = sampling(signal, n1, n2, zero)
        r_xx = autocorrelation(r_xx, x1, x2, zero)
    # phi_xx * hamming window = s[m] in time domain
    # S[K] = DFT(s[m])
    return r_xx


