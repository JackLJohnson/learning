from gen_signal import generate_signal, spectrogram
import numpy as np
from math import ceil, log
from fractions import gcd
import matplotlib.pyplot as plt

def plot_contour(x, y, z):
    z_prim = abs(z)
    plt.contour(x, y, z_prim)

def sampling (signal, n1, n2, zero):
    """
    Return the co-prime sampled signals.
    The format of return values is a 2-d matrix:
        (index in original signal, signal value)
    Input:  signal values (1-d vector)
            n1, n2: the relative sampling points generated by coprime pairs
            zero: relative zero point along with moving window.
    """
    x1 = np.array([[zero+n1[i], signal[zero+n1[i]]] for i in range(len(n1)) if zero+n1[i]<len(signal)])
    x2 = np.array([[zero+n2[i], signal[zero+n2[i]]] for i in range(len(n2)) if zero+n2[i]>=0 and zero+n2[i]<len(signal)])
    return x1, x2

def autocorrelation (r_xx, x1, x2, zero):
    """
    Calculate the autocorrelation operating upon the r_xx.
    Return the modified array of autocorrelation.
    Input:  r_xx: previous autocorrelation.
            x1, x2: co-prime sampled signal.
            zero: relative zero point along with moving window.
    """
    for i in range(len(x1)):
        for j in range(len(x2)):
            index = abs(x1[i][0]-x2[j][0])
            #if index > 255:
            #    continue
            if zero+index < len(r_xx):
                index += zero
                if r_xx[index][1] == 0:
                    r_xx[index][0] = x1[i][1]*(x2[j][1].conj())
                    r_xx[index][1] += 1
                else:
                    r_xx[index][0] = (r_xx[index][1]*r_xx[index][0] + x1[i][1]*(x2[j][1].conj())) / (r_xx[index][1]+1)
                    r_xx[index][1] += 1
    return r_xx

def dft (r_xx, Fs, NFFT, hamming, overlap=True, sides='default'):
    if overlap:
        step = NFFT // 2
    else:
        step = NFFT
    ind = np.arange(0, len(r_xx)-NFFT+ 1, step)
    n = len(ind)
    pad_to = NFFT
    if (sides == 'default' and np.iscomplexobj(r_xx)) or sides == 'twosided':
        numFreqs = pad_to
        scaling_factor = 1.
    elif sides in ('default', 'onesided'):
        numFreqs = pad_to//2 + 1
        scaling_factor = 2.
    else:
        raise ValueError("sides must be one of: 'default', 'onesided', or 'twosided'")
    
    psd = np.zeros((numFreqs, n), np.complex_)
    
    for i in range(n):
        temp = r_xx[ind[i]:(ind[i]+NFFT),0]*hamming
        #psd[:,i] = np.fft.fft(temp, window_size)
        psd[:,i] = np.fft.fft(temp, n=pad_to)[:numFreqs]
        #psd[:,i] = np.conjugate(fx[:numFreqs])*fx[:numFreqs]
    
    # Also include scaling factors for one-sided densities and dividing by the
    # sampling frequency, if desired. Scale everything, except the DC component
    # and the NFFT/2 component:
    psd[1:-1] *= scaling_factor

    # MATLAB divides by the sampling frequency so that density function
    # has units of dB/Hz and can be integrated by the plotted frequency
    # values. Perform the same scaling here.
    psd /= Fs
    
    t = 1./Fs * (ind + NFFT/2.)
    freqs = float(Fs) / pad_to * np.arange(numFreqs)

    if (np.iscomplexobj(r_xx) and sides == 'default') or sides == 'twosided':
        # center the frequency range at zero
        freqs = np.concatenate((freqs[numFreqs//2:] - Fs, freqs[:numFreqs//2]))
        psd = np.concatenate((psd[numFreqs//2:, :], psd[:numFreqs//2, :]), 0)

    return psd, freqs, t

def main (signal, Fs, NFFT, N, M, window_size=256):
    # check the property of co-prime
    assert gcd(N,M) == 1, "The pair a and b should be co-prime."
    # make sure that a is larger than b
    if N < M:
        M = temp
        M = N
        N = temp
    if window_size > N*M:
        window_size = 2**int(log(N*M)/log(2))
    # the times of moving for window
    steps = int(ceil(len(signal)/float(window_size)))
    # calculate the range to generate hole-free co-prime combinations 
    n1 = np.arange(0,N)*M
    n2 = np.arange(-M+1,M)*N
    # r_xx with the same length of signal to store and average estimations
    # 1st column is the value of autocorrelation
    # 2nd column is the # of sample points contribute to this autocorrelation
    r_xx = np.zeros((len(signal),2))
    overlap = False

    for i in range(steps):
        # the relative zero point for the current window
        zero = i*window_size
        # slicing the signal and conduct co-prime sampling 
        x1, x2 = sampling(signal, n1, n2, zero)
        r_xx = autocorrelation(r_xx, x1, x2, zero)
    np.savetxt("rxx.csv", r_xx, fmt="%s", delimiter=' ')
    hamming = np.hamming(NFFT)
    psd, freq, time = dft(r_xx, Fs, NFFT, hamming, overlap)
    plot_contour(time, freq, psd)
    return psd, freq, time


def autocorr(x):
    """Return result of autocorrelation of sequence without any sampling"""
    result = np.correlate(x, x, mode='full')
    return result[result.size/2:]

def fourier (r_xx, Fs, NFFT, hamming, overlap=True, sides='default'):
    if overlap:
        step = NFFT // 2
    else:
        step = NFFT
    ind = np.arange(0, len(r_xx)-NFFT+ 1, step)
    n = len(ind)
    pad_to = NFFT
    if (sides == 'default' and np.iscomplexobj(r_xx)) or sides == 'twosided':
        numFreqs = pad_to
        scaling_factor = 1.
    elif sides in ('default', 'onesided'):
        numFreqs = pad_to//2 + 1
        scaling_factor = 2.
    else:
        raise ValueError("sides must be one of: 'default', 'onesided', or 'twosided'")
    
    psd = np.zeros((numFreqs, n), np.complex_)
    
    for i in range(n):
        temp = r_xx[ind[i]:(ind[i]+NFFT)]*hamming
        #psd[:,i] = np.fft.fft(temp, window_size)
        psd[:,i] = np.fft.fft(temp, n=pad_to)[:numFreqs]
        #psd[:,i] = np.conjugate(fx[:numFreqs])*fx[:numFreqs]
    
    # Also include scaling factors for one-sided densities and dividing by the
    # sampling frequency, if desired. Scale everything, except the DC component
    # and the NFFT/2 component:
    psd[1:-1] *= scaling_factor

    # MATLAB divides by the sampling frequency so that density function
    # has units of dB/Hz and can be integrated by the plotted frequency
    # values. Perform the same scaling here.
    psd /= Fs
    
    t = 1./Fs * (ind + NFFT/2.)
    freqs = float(Fs) / pad_to * np.arange(numFreqs)

    if (np.iscomplexobj(r_xx) and sides == 'default') or sides == 'twosided':
        # center the frequency range at zero
        freqs = np.concatenate((freqs[numFreqs//2:] - Fs, freqs[:numFreqs//2]))
        psd = np.concatenate((psd[numFreqs//2:, :], psd[:numFreqs//2, :]), 0)

    return psd, freqs, t

def benchmark(signal, Fs, NFFT, window_size=256):
    length = len(signal)
    steps = int(ceil(length/float(window_size)))
    r_xx = np.zeros(len(signal))
    overlap = False
    for i in range(steps):
        upper = min((i+1)*window_size, length)
        r_xx[i*window_size:upper] = autocorr(signal[i*window_size:upper])
    hamming = np.hamming(NFFT)
    psd, freq, time = fourier(r_xx, Fs, NFFT, hamming, overlap)
    plot_contour(time, freq, psd)
    return psd, freq, time

